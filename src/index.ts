import { readdir, readFile } from 'fs/promises'
import { join } from 'path'
import type { Plugin as RollupPlugin } from 'rollup'
import type { Plugin as VitePlugin } from 'vite'
import validateSpdx from 'spdx-expression-validate'
import getNpmTarballUrl from 'get-npm-tarball-url'
import fetch from 'node-fetch'

export interface PackageMeta {
  name: string
  author?: string | { name: string; email?: string; url?: string }
  license?: string | { type: string; url?: string }
  licenses?: string | Array<{ type: string; url?: string }>
  repository?: { url: string }
  version: string
}

export interface LicenseMeta {
  name: string
  version: string
  license: string
  licenseText: string
}

interface TestMocks {
  getLicense?: typeof getLicense
  getLicenseFileName?: typeof getLicenseFileName
  readLicenseFileContents?: typeof readLicenseFileContents
  readPackageMeta?: (
    moduleDir: string,
    originalMethod: typeof readPackageMeta
  ) => Promise<PackageMeta>
}

export interface PluginOptions {
  /**
   * Defines additional files that should be generated by this plugin
   * (e.g. an html representation of the licenses in addition to the
   * generated json)
   *
   * Keys represent filenames, values are functions that get invoked
   * with the packages array and should return the content written to
   * the additional file.
   */
  additionalFiles?: {
    [filename: string]: (packages: LicenseMeta[]) => string | Promise<string>
  }
  /**
   * Defines an object to override licenses for specified package versions.
   *
   * Keys have the format <name>@<version>, values are valid spdx license
   * expressions.
   */
  licenseOverrides?: { [packageVersion: string]: string }
  /**
   * Path to the output file that will be generated (relative to the bundle
   * output directory). Defaults to `oss-licenses.json`.
   */
  outputFilename?: string
  /**
   * When this is enabled, packages where no license text was found get their
   * license text from spdx.org. Defaults to `false`.
   */
  replenishDefaultLicenseTexts?: boolean
  /**
   * A method to define license identifiers as unacceptable. It is invoked
   * with the licenseIdentifier of every package and should return `true` when
   * the license is unacceptable and encountering it should fail the build.
   */
  unacceptableLicenseTest?: (licenseIdentifier: string) => boolean
  /**
   * A method to exclude packages from the process. It is invoked with
   * packageName and packageVersion of every package and should return
   * `true` to exclude the package.
   */
  excludedPackageTest?: (packageName: string, packageVersion: string) => boolean
  /**
   * Used to define packages that should always be included in the output.
   * It must return an array containing the absolute paths of those packages.
   * This function can be async or return a Promise.
   */
  includePackages?: () => string[] | Promise<string[]>
  /**
   * Sets preferred licenses in case multiple licenses for a package
   * can be chosen from.
   */
  preferredLicenses?: string[]
  /** internal use for mocking */
  __mocks__?: TestMocks
}

const defaultLicenseTextCache: { [license: string]: string | null } = {}

async function getDefaultLicenseText(license: string) {
  if (!defaultLicenseTextCache[license]) {
    const response = await fetch(
      `https://raw.githubusercontent.com/spdx/license-list-data/master/text/${license}.txt`
    )
    const responseText = await response.text()
    defaultLicenseTextCache[license] = responseText
  }

  return defaultLicenseTextCache[license]
}

async function readPackageMeta(moduleDir: string): Promise<PackageMeta> {
  const path = join(moduleDir, 'package.json')
  const contents = await readFile(path, 'utf-8')
  return JSON.parse(contents) as PackageMeta
}

function getRepository(meta: PackageMeta): string | null {
  if (meta.repository && meta.repository.url) {
    return meta.repository.url
  } else if (typeof meta.repository === 'string') {
    return meta.repository
  }

  return null
}

async function getLicenseFileName(
  moduleDir: string
): Promise<string | undefined> {
  return (await readdir(moduleDir, { withFileTypes: true }))
    .filter((dirent) => !dirent.isDirectory())
    .map((dirent) => dirent.name)
    .find((name) => !!/^licen[cs]e/i.test(name))
}

async function readLicenseFileContents(path: string) {
  return await readFile(path, 'utf-8')
}

async function getLicenseText(
  packageId: string,
  license: string,
  moduleDir: string,
  pluginOptions: PluginOptions = {}
): Promise<string | null> {
  const getLicenseFileNameFn =
    pluginOptions.__mocks__?.getLicenseFileName ?? getLicenseFileName
  const readLicenseFileContentsFn =
    pluginOptions.__mocks__?.readLicenseFileContents ?? readLicenseFileContents

  if (license && license.indexOf('SEE LICENSE IN ') === 0) {
    const filename = license.split(' ')[3]
    try {
      return await readLicenseFileContentsFn(join(moduleDir, filename))
    } catch (e) {
      throw new Error(
        `Could not find file specified in package.json license field of ${packageId}`
      )
    }
  }

  const licenseFilename = await getLicenseFileNameFn(moduleDir)

  if (licenseFilename !== undefined) {
    return await readLicenseFileContentsFn(join(moduleDir, licenseFilename))
  }

  if (pluginOptions.replenishDefaultLicenseTexts) {
    return await getDefaultLicenseText(license)
  }

  return null
}

function findPreferredLicense(
  licenses: string[],
  preferredLicenses: string[]
): string | null {
  for (const preferredLicense of preferredLicenses) {
    for (const license of licenses) {
      if (preferredLicense === license) {
        return preferredLicense
      }
    }
  }

  return null
}

function getLicense(
  packageId: string,
  meta: PackageMeta,
  pluginOptions: PluginOptions = {}
): string {
  let license: string

  if (
    pluginOptions.licenseOverrides &&
    pluginOptions.licenseOverrides[packageId]
  ) {
    license = pluginOptions.licenseOverrides[packageId]
  } else if (typeof meta.license === 'object') {
    license = meta.license.type
  } else if (meta.license) {
    license = meta.license
  } else if (Array.isArray(meta.licenses) && meta.licenses.length > 0) {
    // handle deprecated `licenses` field
    license =
      findPreferredLicense(
        meta.licenses.map((l) => l.type),
        pluginOptions.preferredLicenses ?? []
      ) ?? meta.licenses[0].type
  } else if (typeof meta.licenses === 'string') {
    // handle invalid string values for deprecated `licenses` field
    // unfortunately, these are rather common
    license = meta.licenses
  }

  if (!license) {
    throw new Error(`Could not find license info for ${packageId}`)
  } else if (
    pluginOptions.unacceptableLicenseTest &&
    pluginOptions.unacceptableLicenseTest(license)
  ) {
    throw new Error(`Found unacceptable license "${license}" for ${packageId}`)
  } else if (!validateSpdx(license)) {
    throw new Error(
      `License "${license}" for ${packageId} is not a valid SPDX expression!`
    )
  }

  return license
}

export function createRollupLicensePlugin(
  pluginOptions: PluginOptions = {},
  pluginName: string = 'rollup-license-plugin'
): RollupPlugin {
  const moduleDirs = new Set<string>()

  return {
    name: pluginName,

    renderChunk(_code, chunk) {
      Object.entries(chunk.modules)
        .filter(
          ([path, module]) =>
            Boolean(path.match(/node_modules/)) && module.renderedLength > 0
        )
        .map(([path]) =>
          path.startsWith('\0') ? path.replace(/^\0/, '') : path
        )
        .map((path) => [path, path.split('node_modules').pop()])
        .map(([path, filePath]) => {
          const segments = filePath.replace(/^\//, '').split('/')
          const packageName = segments[0].startsWith('@')
            ? `${segments[0]}/${segments[1]}`
            : segments[0]
          return path.replace(filePath, '') + `/${packageName}`
        })
        .forEach((moduleDir) => moduleDirs.add(moduleDir))

      return null
    },

    async generateBundle() {
      const licenseMeta = []

      const getLicenseFn = pluginOptions.__mocks__?.getLicense ?? getLicense

      if (pluginOptions.includePackages) {
        for (const moduleDir of await pluginOptions.includePackages()) {
          moduleDirs.add(moduleDir)
        }
      }

      for (const moduleDir of Array.from(moduleDirs)) {
        const meta = await (pluginOptions.__mocks__?.readPackageMeta
          ? pluginOptions.__mocks__.readPackageMeta(moduleDir, readPackageMeta)
          : readPackageMeta(moduleDir))
        const packageId = `${meta.name}@${meta.version}`
        if (
          pluginOptions.excludedPackageTest &&
          pluginOptions.excludedPackageTest(meta.name, meta.version)
        ) {
          continue
        }

        const license = getLicenseFn(packageId, meta, pluginOptions)
        const licenseText = await getLicenseText(
          packageId,
          license,
          moduleDir,
          pluginOptions
        )
        const repository = getRepository(meta)

        const source = getNpmTarballUrl(meta.name, meta.version)
        licenseMeta.push({
          name: meta.name,
          version: meta.version,
          author: meta.author,
          repository,
          source,
          license,
          licenseText,
        })
      }

      this.emitFile({
        type: 'asset',
        source: JSON.stringify(licenseMeta, null, 2),
        fileName: pluginOptions.outputFilename ?? 'oss-licenses.json',
      })

      if (pluginOptions.additionalFiles) {
        for (const fileName of Object.keys(pluginOptions.additionalFiles)) {
          const source =
            await pluginOptions.additionalFiles[fileName](licenseMeta)
          this.emitFile({ type: 'asset', source, fileName })
        }
      }
    },
  }
}

export function createViteLicensePlugin(
  pluginOptions: PluginOptions = {}
): VitePlugin {
  const pluginName = 'vite-license-plugin'

  return {
    ...createRollupLicensePlugin(pluginOptions, pluginName),
    name: pluginName,
    apply: 'build',
  }
}
